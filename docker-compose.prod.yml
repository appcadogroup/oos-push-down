services:
  # Run migrations once, then exit successfully.
  migrate:
    build:
      context: .
      dockerfile: apps/backend/Dockerfile.prod
    env_file: .env.prod
    environment:
      DATABASE_URL: ${DATABASE_URL}
    command: ["npm","run","-w","packages/db","migrate:deploy"]
    restart: "no"

  backend:
    build:
      context: .
      dockerfile: apps/backend/Dockerfile.prod
    env_file: .env.prod
    environment:
      NODE_ENV: production
      DATABASE_URL: ${DATABASE_URL}
      REDIS_URL: ${REDIS_URL}
      SCOPES: ${SCOPES}
      SHOPIFY_API_KEY: ${SHOPIFY_API_KEY}
      SHOPIFY_API_SECRET: ${SHOPIFY_API_SECRET}
      APP_URL: https://${APP_HOST}
    restart: unless-stopped
    depends_on:
      migrate:
        condition: service_completed_successfully

  # worker:
  #   image: oos-push-down-backend                       # or build: { context: ., dockerfile: apps/backend/Dockerfile.prod }
  #   command: ["node","apps/backend/dist/jobs/workers/index.js"]
  #   env_file: .env.prod
  #   environment:
  #     NODE_ENV: production
  #     DATABASE_URL: ${DATABASE_URL}
  #     REDIS_URL: ${REDIS_URL}
  #     NODE_OPTIONS: --max-old-space-size=256
  #   depends_on:
  #     migrate:
  #       condition: service_completed_successfully
  #   restart: unless-stopped

  frontend:
    build:
      context: .
      dockerfile: apps/frontend/Dockerfile.prod
    env_file: .env.prod
    environment:
      NODE_ENV: production
      DATABASE_URL: ${DATABASE_URL}
      API_BASE_URL: http://backend:3012
      APP_URL: https://${APP_HOST}
      SHOPIFY_API_KEY: ${SHOPIFY_API_KEY}

    depends_on:
      backend:
        condition: service_started

  # TLS terminator + reverse proxy
  nginx:
    image: nginx:1.27-alpine
    env_file: .env.prod
    ports:
      - "80:80"
      - "443:443"
    volumes:
      # - ./ops/nginx/templates/app.http.conf.template:/etc/nginx/templates/app.conf.template:ro
      - ./ops/nginx/templates/app.https.conf.template:/etc/nginx/templates/app.conf.template:ro
      - letsencrypt:/etc/letsencrypt
      - certbot-webroot:/var/www/certbot
    depends_on:
      frontend:
        condition: service_started
      backend:
        condition: service_started

  # One-shot certificate issuance (run this once per domain)
  certbot-init:
    image: certbot/certbot:latest
    volumes:
      - letsencrypt:/etc/letsencrypt
      - certbot-webroot:/var/www/certbot
    entrypoint: ["/bin/sh","-lc"]
    env_file: .env.prod
    command: >
      "certbot certonly --non-interactive --agree-tos
      --email appcadogroup@gmail.com
      --webroot -w /var/www/certbot
      -d push-down-and-hide-out-of-stock.sincoeec.com
      --rsa-key-size 4096
      && echo 'Certificates obtained'"

  # Manual/cron-style renew runner (run when you want to renew; see section 4)
  certbot-renew:
    image: certbot/certbot:latest
    env_file: .env.prod
    volumes:
      - letsencrypt:/etc/letsencrypt
      - certbot-webroot:/var/www/certbot
    entrypoint: ["/bin/sh","-lc"]
    command: >
      "certbot renew --webroot -w /var/www/certbot --quiet
      && echo 'Renewed. Reload nginx on host: docker compose -f docker-compose.prod.yml exec nginx nginx -s reload'"

volumes:
  letsencrypt:
  certbot-webroot:
